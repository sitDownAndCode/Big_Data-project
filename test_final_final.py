import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns


from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

from sklearn.decomposition import PCA
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import MinMaxScaler
from matplotlib.patches import Ellipse




# Load the cleaned dataset
df = pd.read_csv('cleaned_data.csv')

# Check the first few rows
df.head()


# Select only columns that are of numeric types (int, float, or decimal)
df_cleaned = df.select_dtypes(include=['int64', 'float64'])  # Specifically for int and float columns


# Check the first few rows of the cleaned dataframe
df_cleaned.head()


scaler = StandardScaler()
df_scaled = scaler.fit_transform(df_cleaned)





# Use the Elbow Method to find the optimal number of clusters
inertia = []
for k in range(1, 61):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df_scaled)
    inertia.append(kmeans.inertia_)

# Plot the inertia to find the "elbow"
plt.plot(range(1, 61), inertia)
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.title('Elbow Method')
plt.show()





# bend is at 11 approx
kmeans = KMeans(n_clusters=11)
df['Cluster'] = kmeans.fit_predict(df_scaled)  # Assign cluster labels to the dataframe


pca = PCA(n_components=2)
pca_components = pca.fit_transform(df_scaled)




# Plot the clusters
plt.figure(figsize=(10, 8))
plt.scatter(pca_components[:, 0], pca_components[:, 1], c=df['Cluster'], cmap='viridis')

# Add ellipses for each cluster (boundary only)
ax = plt.gca()
colors = plt.cm.viridis(np.linspace(0, 1, 11))  # Use the same colormap for clusters

# Draw ellipse boundary for each cluster
for i in range(11):
    # Get points from the cluster
    cluster_points = pca_components[df['Cluster'] == i]

    # Calculate the mean and covariance of the points in the cluster
    mean = cluster_points.mean(axis=0)
    cov = np.cov(cluster_points.T)

    # Calculate the eigenvalues and eigenvectors of the covariance matrix
    eigenvalues, eigenvectors = np.linalg.eig(cov)

    # Get the angle of the ellipse
    angle = np.arctan2(*eigenvectors[:, 0][::-1]) * 180 / np.pi

    # Get the width and height of the ellipse
    width, height = 2 * np.sqrt(eigenvalues)

    # Create an ellipse patch with no fill (empty inside)
    ellipse = Ellipse(xy=mean, width=width, height=height, angle=angle, 
                      edgecolor='black', facecolor='none', linewidth=3)  # Set facecolor='none' for empty inside
    ax.add_patch(ellipse)

# Plot the final figure
plt.title('K-Means Clusters with Ellipses (k=11) - Boundaries Only')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.colorbar(label='Cluster')
plt.show()


# Select only numeric columns (int, float, or decimal)
numeric_columns = df.select_dtypes(include=['number'])

# Calculate and print 5 summary statistics for numeric columns per cluster
summary_stats = df.groupby('Cluster')[numeric_columns.columns].agg(['count', 'mean', 'std', 'min', 'max'])

# Flatten MultiIndex columns for cleaner output
summary_stats.columns = ['_'.join(col).strip() for col in summary_stats.columns.values]

# Print the summary statistics
print(summary_stats)





# Print data and 5 summary statistics for each cluster
for cluster_id in range(11):
    print(f"\n===== Cluster {cluster_id} =====")
    
    # Filter data for the current cluster
    cluster_data = df[df['Cluster'] == cluster_id]
    
    # Print the first few rows of data in the cluster
    print("Sample Data:")
    print(cluster_data.head())

    # Print 5 summary statistics for numeric columns
    print("\nSummary Statistics:")
    print(cluster_data.describe().loc[['count', 'mean', 'std', 'min', 'max']])









# 1. Apply Binning to Age, Purchase Amount, and Previous Purchases
# Bin Age
df['Age_Bin'] = pd.cut(df['Age'], bins=[0, 18, 24, 34, 44, 54, 64, 101], labels=["0", "1", "2", "3", "4", "5", "6"])

# Bin Purchase Amount (USD)
df['Spend_Bin'] = pd.cut(df['Purchase Amount (USD)'], bins=[0, 20, 40, 60, 80, 101], labels=["0", "1", "2", "3", "4"])

# Bin Previous Purchases
df['Previous_Purchase_Bin'] = pd.cut(df['Previous Purchases'], bins=[0, 25, 50, 75, 101], labels=["0-25", "25-50", "50-75", "75+"])





# 2. Plot the tables generated by SQL

# Plot for Age Group vs Customer Count
age_group_count = df.groupby('Age_Bin', observed=True).size().reset_index(name='Customer_Count')
sns.barplot(x='Age_Bin', y='Customer_Count', data=age_group_count)
plt.title('Customer Count by Age Group')
plt.show()

# Plot for Purchase Amount (USD) vs Customer Count
spend_group_count = df.groupby('Spend_Bin', observed=True).size().reset_index(name='Customer_Count')
sns.barplot(x='Spend_Bin', y='Customer_Count', data=spend_group_count)
plt.title('Customer Count by Spend Bin')
plt.show()

# Plot for Previous Purchases vs Customer Count
previous_purchase_count = df.groupby('Previous_Purchase_Bin', observed=True).size().reset_index(name='Customer_Count')
sns.barplot(x='Previous_Purchase_Bin', y='Customer_Count', data=previous_purchase_count)
plt.title('Customer Count by Previous Purchases Bin')
plt.show()

# Plot for Gender Distribution
gender_distribution = df.groupby('Gender').size().reset_index(name='Count')
gender_distribution['Percentage'] = (gender_distribution['Count'] / gender_distribution['Count'].sum()) * 100
sns.barplot(x='Gender', y='Count', data=gender_distribution)
plt.title('Gender Distribution')
plt.show()

# Plot for Purchase Amount vs Category
category_revenue = df.groupby('Category')['Purchase Amount (USD)'].sum().reset_index(name='Total_Revenue')
sns.barplot(x='Category', y='Total_Revenue', data=category_revenue)
plt.title('Total Revenue by Category')
plt.xticks(rotation=90)
plt.show()

# Plot for Item Purchased vs Total Spending
item_spending = df.groupby('Item Purchased')['Purchase Amount (USD)'].sum().reset_index(name='Total_Spending')
sns.barplot(x='Item Purchased', y='Total_Spending', data=item_spending)
plt.title('Total Spending by Item Purchased')
plt.xticks(rotation=90)
plt.show()

# Plot for Purchase Frequency vs Customer Count
purchase_frequency_count = df.groupby('Frequency of Purchases').size().reset_index(name='Customer_Count')
sns.barplot(x='Frequency of Purchases', y='Customer_Count', data=purchase_frequency_count)
plt.title('Customer Count by Frequency of Purchases')
plt.show()












# 1. Scatter plot: Age vs Spender Score
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='Age', y='SpenderScore', hue='Gender', alpha=0.7, s=100)
plt.title('Age vs Spender Score')
plt.xlabel('Age')
plt.ylabel('Spender Score')
plt.show()

# 2. Boxplot: Spender Score by Cluster
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Cluster', y='SpenderScore', hue='Cluster', palette='viridis', legend=False)
plt.title('Spender Score Distribution by Cluster')
plt.xlabel('Cluster')
plt.ylabel('Spender Score')
plt.show()







# Apply DBSCAN clustering
dbscan = DBSCAN(eps=0.5, min_samples=5)
df['DBSCAN_Cluster'] = dbscan.fit_predict(df_scaled)

# Verify if 'DBSCAN_Cluster' is correctly added to the DataFrame
print(df[['DBSCAN_Cluster']].head())  # Print the first few rows of DBSCAN_Cluster column

# Check for any issues with the DBSCAN clustering column
if 'DBSCAN_Cluster' not in df.columns:
    print("Error: 'DBSCAN_Cluster' column not found.")
else:
    print("'DBSCAN_Cluster' column is successfully added.")





# Plot the DBSCAN clusters
plt.figure(figsize=(10, 8))
plt.scatter(pca_components[:, 0], pca_components[:, 1], c=df['DBSCAN_Cluster'], cmap='viridis', alpha=0.6)
plt.title('DBSCAN Clustering (eps=0.5, min_samples=5)')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.colorbar(label='Cluster')
plt.show()

# Scatter plot for DBSCAN clusters
plt.figure(figsize=(10, 6))
sns.scatterplot(x=pca_components[:, 0], y=pca_components[:, 1], hue=df['DBSCAN_Cluster'], palette='viridis', alpha=0.7, s=100)
plt.title('DBSCAN Clustering Results')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.legend(title='Cluster', loc='best')
plt.show()

# Print summary statistics for DBSCAN clusters
for cluster_id in np.unique(df['DBSCAN_Cluster']):
    print(f"\n===== DBSCAN Cluster {cluster_id} =====")
    
    # Filter data for the current DBSCAN cluster
    cluster_data = df[df['DBSCAN_Cluster'] == cluster_id]
    
    # Print the first few rows of data in the cluster
    print("Sample Data:")
    print(cluster_data.head())

    # Print summary statistics for numeric columns
    print("\nSummary Statistics:")
    print(cluster_data.describe().loc[['count', 'mean', 'std', 'min', 'max']])

# Additional Plots for DBSCAN Clustering

# 1. Plot: DBSCAN Cluster Sizes
cluster_sizes = df['DBSCAN_Cluster'].value_counts().reset_index()
cluster_sizes.columns = ['Cluster', 'Size']
sns.barplot(x='Cluster', y='Size', data=cluster_sizes)
plt.title('DBSCAN Cluster Sizes')
plt.show()

# 2. Boxplot: DBSCAN Cluster Distribution (example with SpenderScore)
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='DBSCAN_Cluster', y='SpenderScore', palette='viridis', showfliers=False)
plt.title('Spender Score Distribution by DBSCAN Cluster')
plt.xlabel('DBSCAN Cluster')
plt.ylabel('Spender Score')
plt.show()

# 3. Plot: DBSCAN Cluster vs Frequency of Purchases
purchase_frequency_count = df.groupby('DBSCAN_Cluster')['Frequency of Purchases'].size().reset_index(name='Customer_Count')
sns.barplot(x='DBSCAN_Cluster', y='Customer_Count', data=purchase_frequency_count)
plt.title('Customer Count by DBSCAN Cluster')
plt.show()

